/**
 * Transformer to replace @validateArgs() calls with the version
 * generated by the validator generator.
 *
 * This MUST be executed after the validator files are generated.
 */

import path from "node:path";
import ts from "typescript";

/**
 * Creates a transformer that transforms @validateArgs() decorators in source files:
 * - Renames decorators to validateArgs_ClassName_MethodName
 * - Strips decorator arguments (options are baked into the generated validator)
 * - Replaces the @zwave-js/transformers import with the generated ._validateArgs.js import
 */
export function createValidateArgsTransformer(): ts.TransformerFactory<
	ts.SourceFile
> {
	return (context: ts.TransformationContext) => (file: ts.SourceFile) => {
		// Bail early if there is no import for "@zwave-js/transformers"
		if (!file.getFullText().includes("@zwave-js/transformers")) {
			return file;
		}

		const f = context.factory;

		let className: string | undefined;
		let methodName: string | undefined;
		const renamedDecorators: ts.Identifier[] = [];

		function renameDecorators(node: ts.Node): ts.Node {
			if (ts.isClassDeclaration(node) && node.name) {
				className = node.name.text;
				const ret = ts.visitEachChild(node, renameDecorators, context);
				className = undefined;
				return ret;
			}

			if (className && ts.isMethodDeclaration(node) && node.name) {
				methodName = node.name.getText(file);
				const ret = ts.visitEachChild(node, renameDecorators, context);
				methodName = undefined;
				return ret;
			}

			if (
				className
				&& methodName
				&& ts.isDecorator(node)
				&& ts.isCallExpression(node.expression)
				&& ts.isIdentifier(node.expression.expression)
				&& node.expression.expression.text === "validateArgs"
			) {
				const newName = f.createIdentifier(
					`validateArgs_${className}_${methodName}`,
				);
				renamedDecorators.push(newName);
				// Strip the arguments - options are baked into the generated validator
				const newCallExpression = f.updateCallExpression(
					node.expression,
					newName,
					undefined,
					[],
				);
				return f.updateDecorator(node, newCallExpression);
			}

			return ts.visitEachChild(node, renameDecorators, context);
		}

		file = ts.visitNode(file, renameDecorators) as ts.SourceFile;

		// Remove @zwave-js/transformers import
		const selfImports = file.statements
			.filter((s): s is ts.ImportDeclaration => ts.isImportDeclaration(s))
			.filter(
				(i) =>
					i.moduleSpecifier
						.getText(file)
						.replaceAll(/^["']|["']$/g, "")
						=== "@zwave-js/transformers",
			);

		// Create replacement import
		const extension = file.fileName.match(/\.[mc]?[jt]s$/)?.[0];
		const fileNameOnly = path.basename(file.fileName, extension);
		// Use the appropriate JS extension based on the source file extension
		const jsExtension = extension === ".mts"
			? ".mjs"
			: extension === ".cts"
			? ".cjs"
			: ".js";
		const newImport = f.createImportDeclaration(
			undefined,
			f.createImportClause(
				undefined,
				undefined,
				f.createNamespaceImport(f.createIdentifier("__validateArgs")),
			),
			f.createStringLiteral(
				`./${fileNameOnly}._validateArgs${jsExtension}`,
			),
		);

		// We need to destructure the replacement import, because at this stage TS does
		// not understand that we're creating an import and use it later in the file
		const destructure = f.createVariableStatement(
			undefined,
			f.createVariableDeclarationList(
				[
					f.createVariableDeclaration(
						f.createObjectBindingPattern(
							renamedDecorators.map((d) =>
								f.createBindingElement(
									undefined,
									undefined,
									d,
									undefined,
								)
							),
						),
						undefined,
						undefined,
						f.createIdentifier("__validateArgs"),
					),
				],
				ts.NodeFlags.Const,
			),
		);

		if (selfImports.length > 0) {
			file = f.updateSourceFile(
				file,
				[
					newImport,
					destructure,
					...file.statements.filter(
						(s) => !selfImports.includes(s as ts.ImportDeclaration),
					),
				],
				file.isDeclarationFile,
				file.referencedFiles,
				file.typeReferenceDirectives,
				file.hasNoDefaultLib,
				file.libReferenceDirectives,
			);
		}

		return file;
	};
}
