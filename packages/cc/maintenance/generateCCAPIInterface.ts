/*!
 * This script generates the `CCNameMap` type and `CCAPIs` interface
 * which are used to strongly-type the simplified API exposed via
 * `ZWaveNode.commandClasses.xyz`
 */

import { formatWithDprint } from "@zwave-js/maintenance";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { type SourceFile } from "ts-morph";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const apiRegex = /^@API\(CommandClasses(?:\.|\[)(.+?)(?:\])?\)/m;
const classNameRegex = /class ([^\s]+) extends (\w+)?CCAPI/;
const libDir = path.join(__dirname, "..", "src/lib");
const generatedFile = path.join(libDir, "_CCAPI.generated.ts");

process.on("unhandledRejection", (r) => {
	throw r;
});

interface CCWithAPI {
	name: string;
	className: string;
	file: string;
}

/**
 * Auxiliary file generator for runCodegen.
 * Generates lib/_CCAPI.generated.ts with CCNameMap and CCAPIs types.
 */
export async function generateCCAPIInterfaceFile(
	sourceFiles: SourceFile[],
	srcDir: string,
): Promise<Map<string, string>> {
	const CCsWithAPI: CCWithAPI[] = [];

	for (const sf of sourceFiles) {
		const filePath = sf.getFilePath();
		const relativePath = path.relative(srcDir, filePath).replaceAll(
			"\\",
			"/",
		);

		// Only look at cc/*.ts files
		if (!relativePath.startsWith("cc/")) continue;
		if (relativePath.endsWith(".test.ts")) continue;
		if (relativePath.includes(".generated.")) continue;

		const fileContent = sf.getFullText();
		// Extract the CC name from e.g. `@API(CommandClasses["Binary Sensor"])`
		const apiMatch = apiRegex.exec(fileContent);
		// Extract the class name from e.g. `export class BasicCCAPI extends CCAPI`
		const classMatch = classNameRegex.exec(fileContent);
		if (apiMatch && classMatch) {
			CCsWithAPI.push({
				file: path.basename(filePath).replace(/\.ts$/, ".js"),
				name: apiMatch[1],
				className: classMatch[1],
			});
		}
	}

	console.log(`Found ${CCsWithAPI.length} API classes...`);

	// Sort by name for consistent output
	CCsWithAPI.sort((a, b) => a.name.localeCompare(b.name));

	// Relative path from lib/ to cc/
	const ccRelativePath = "../cc";

	let content =
		`// This file is auto-generated by maintenance/generateCCAPIInterface.ts
// Do not edit it by hand or your changes will be lost!

import type { CommandClasses } from "@zwave-js/core";
import type { CCAPI } from "./API.js";

// Maps CC names to their CommandClasses enum values
export type CCNameMap = {
`;

	for (const { name } of CCsWithAPI) {
		const quotedName = name.startsWith(`"`) ? name : `"${name}"`;
		content += `\t${quotedName}: typeof CommandClasses[${quotedName}];\n`;
	}

	content += `};

// Maps CC names to their API class types
export interface CCAPIs {
\t[Symbol.iterator](): Iterator<CCAPI>;

`;

	for (const { name, className, file } of CCsWithAPI) {
		const quotedName = name.startsWith(`"`) ? name : `"${name}"`;
		content +=
			`\t${quotedName}: import("${ccRelativePath}/${file}").${className};\n`;
	}

	content += `}
`;

	return new Map([[
		"lib/_CCAPI.generated.ts",
		formatWithDprint(generatedFile, content),
	]]);
}
